import { readFileSync, writeFileSync, existsSync, mkdirSync } from "node:fs";
import { resolve, dirname } from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = dirname(fileURLToPath(import.meta.url));
const root = resolve(__dirname, "..");
const fixturesDir = resolve(root, "docs/fixtures");
const indexPath = resolve(fixturesDir, "index.json");
const snippetsRoot = resolve(root, "docs/snippets");
const docPath = resolve(root, "docs/AGENT_INTEGRATION.md");

const checkMode = process.argv.includes("--check");

const REQUIRED_RESPONSE_KEYS = [
  "ok",
  "schema_version",
  "repo",
  "range",
  "options",
  "stats",
  "sections",
  "items",
  "markdown",
];

function stableJson(obj) {
  return `${JSON.stringify(obj, null, 2)}\n`;
}

function shellEscapeSingleQuotes(str) {
  return String(str).replace(/'/g, "'\\''");
}

function assert(condition, message) {
  if (!condition) throw new Error(message);
}

function readJson(path) {
  return JSON.parse(readFileSync(path, "utf8"));
}

function ensureRequiredResponseKeys(fixture, fixtureId) {
  for (const key of REQUIRED_RESPONSE_KEYS) {
    if (!(key in fixture.response)) {
      throw new Error(`Fixture '${fixtureId}' missing response key: ${key}`);
    }
  }
}

function validateFixture(entry, fixture) {
  const fixtureId = entry.id;
  assert(fixture.id === fixtureId, `Fixture id mismatch: index '${fixtureId}' vs file '${fixture.id}'`);
  assert(typeof fixture.description === "string" && fixture.description.length > 0, `Fixture '${fixtureId}' missing description`);
  assert(Array.isArray(fixture.tags), `Fixture '${fixtureId}' missing tags array`);
  assert(typeof fixture.service?.endpoint === "string" && fixture.service.endpoint.length > 0, `Fixture '${fixtureId}' missing service.endpoint`);
  assert(fixture.request && typeof fixture.request === "object", `Fixture '${fixtureId}' missing request object`);
  assert(fixture.response && typeof fixture.response === "object", `Fixture '${fixtureId}' missing response object`);

  const req = fixture.request;
  assert(typeof req.repo === "string" && req.repo.length > 0, `Fixture '${fixtureId}' request.repo is required`);
  assert(["standard", "short"].includes(req.preset), `Fixture '${fixtureId}' request.preset invalid`);
  assert(["release", "update", "social", "internal"].includes(req.destination), `Fixture '${fixtureId}' request.destination invalid`);

  ensureRequiredResponseKeys(fixture, fixtureId);
}

function buildFixtureSnippets(fixture) {
  const endpoint = fixture.service.endpoint;
  const request = fixture.request;
  const response = fixture.response;

  const requestJson = stableJson(request);
  const responseJson = stableJson(response);

  const curlSnippet = [
    "#!/usr/bin/env bash",
    "set -euo pipefail",
    "",
    `curl -sS -X POST '${endpoint}' \\\n  -H 'content-type: application/json' \\\n  -d '${shellEscapeSingleQuotes(requestJson.trim())}' | jq .`,
    "",
  ].join("\n");

  const pythonSnippet = [
    "import requests",
    "",
    `URL = \"${endpoint}\"`,
    `payload = ${requestJson.trim()}`,
    "",
    "response = requests.post(URL, json=payload, timeout=30)",
    "response.raise_for_status()",
    "data = response.json()",
    "print(data[\"schema_version\"])",
    "print(data[\"sections\"][\"what_shipped\"])",
    "",
  ].join("\n");

  const jsSnippet = [
    `const url = \"${endpoint}\";`,
    `const payload = ${requestJson.trim()};`,
    "",
    "const res = await fetch(url, {",
    "  method: \"POST\",",
    "  headers: { \"content-type\": \"application/json\" },",
    "  body: JSON.stringify(payload),",
    "});",
    "if (!res.ok) throw new Error(`HTTP ${res.status}`);",
    "const data = await res.json();",
    "console.log(data.schema_version);",
    "console.log(data.sections.what_shipped);",
    "",
  ].join("\n");

  return {
    requestJson,
    responseJson,
    curlSnippet,
    pythonSnippet,
    jsSnippet,
  };
}

function buildIntegrationDoc(fixtures) {
  const lines = [
    "# Agent Integration Examples",
    "",
    "_This file is generated by `scripts/generate-snippets.mjs`. Do not edit manually._",
    "",
    "All examples come from canonical fixtures in `docs/fixtures/`.",
    "",
    "## Scenarios",
    "",
    "| Fixture | Preset | Destination | Why section | Notes |",
    "|---|---|---|---|---|",
  ];

  for (const fx of fixtures) {
    const req = fx.fixture.request;
    lines.push("| `" + fx.id + "` | `" + req.preset + "` | `" + req.destination + "` | `" + Boolean(req.includeWhy) + "` | " + fx.fixture.description + " |");
  }

  lines.push(
    "",
    "## Regenerate",
    "",
    "```bash",
    "npm run snippets:generate",
    "npm run snippets:check",
    "```",
    ""
  );

  for (const fx of fixtures) {
    const req = fx.fixture.request;
    const relBase = `docs/snippets/${fx.id}`;
    lines.push(
      `## ${fx.id}`,
      "",
      `- Description: ${fx.fixture.description}`,
      `- Tags: ${fx.fixture.tags.join(", ")}`,
      `- Request mode: preset=\`${req.preset}\`, destination=\`${req.destination}\`, includeWhy=\`${Boolean(req.includeWhy)}\``,
      `- Generated files: \`${relBase}/request.json\`, \`${relBase}/response.json\`, \`${relBase}/curl.sh\`, \`${relBase}/python.py\`, \`${relBase}/javascript.mjs\``,
      "",
      "### Canonical request",
      "```json",
      fx.snippets.requestJson.trim(),
      "```",
      "",
      "### Canonical response",
      "```json",
      fx.snippets.responseJson.trim(),
      "```",
      "",
      "### cURL",
      "```bash",
      fx.snippets.curlSnippet.trim(),
      "```",
      "",
      "### Python",
      "```python",
      fx.snippets.pythonSnippet.trim(),
      "```",
      "",
      "### JavaScript",
      "```javascript",
      fx.snippets.jsSnippet.trim(),
      "```",
      ""
    );
  }

  lines.push(
    "## Add a new fixture",
    "",
    "1. Add a fixture file under `docs/fixtures/`.",
    "2. Register it in `docs/fixtures/index.json` with unique `id` and `path`.",
    "3. Run `npm run snippets:generate`.",
    "4. Run `npm test` and `npm run snippets:check`.",
    ""
  );

  return `${lines.join("\n")}`;
}

function writeOrCheck(path, content) {
  if (!existsSync(path)) {
    if (checkMode) {
      throw new Error(`Missing generated file: ${path}`);
    }
    mkdirSync(dirname(path), { recursive: true });
    writeFileSync(path, content, "utf8");
    return;
  }

  const existing = readFileSync(path, "utf8");
  if (existing === content) return;

  if (checkMode) {
    throw new Error(`Generated file out of date: ${path}`);
  }

  writeFileSync(path, content, "utf8");
}

function main() {
  const index = readJson(indexPath);
  assert(Array.isArray(index.fixtures) && index.fixtures.length > 0, "fixtures/index.json must include non-empty fixtures array");

  const seenIds = new Set();
  const fixtures = [];

  for (const entry of index.fixtures) {
    assert(typeof entry.id === "string" && entry.id.length > 0, "Fixture index entry missing id");
    assert(typeof entry.path === "string" && entry.path.length > 0, `Fixture '${entry.id}' missing path`);
    if (seenIds.has(entry.id)) throw new Error(`Duplicate fixture id in index: ${entry.id}`);
    seenIds.add(entry.id);

    const fixturePath = resolve(fixturesDir, entry.path);
    const fixture = readJson(fixturePath);
    validateFixture(entry, fixture);

    fixtures.push({
      id: entry.id,
      entry,
      fixture,
      snippets: buildFixtureSnippets(fixture),
    });
  }

  const outputs = {};
  for (const fx of fixtures) {
    const base = resolve(snippetsRoot, fx.id);
    outputs[resolve(base, "request.json")] = fx.snippets.requestJson;
    outputs[resolve(base, "response.json")] = fx.snippets.responseJson;
    outputs[resolve(base, "curl.sh")] = fx.snippets.curlSnippet;
    outputs[resolve(base, "python.py")] = fx.snippets.pythonSnippet;
    outputs[resolve(base, "javascript.mjs")] = fx.snippets.jsSnippet;
  }
  outputs[docPath] = buildIntegrationDoc(fixtures);

  for (const [path, content] of Object.entries(outputs)) {
    writeOrCheck(path, content);
  }

  console.log(checkMode ? "snippets:check ok" : `snippets:generate wrote ${Object.keys(outputs).length} files`);
}

main();
